% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/nkde_execution_functions.R
\name{nkde}
\alias{nkde}
\title{Network Kernel density estimate}
\usage{
nkde(
  lines,
  events,
  w,
  samples,
  kernel_name,
  bw,
  adaptive = FALSE,
  trim_bw = NULL,
  method,
  div = "bw",
  diggle_correction = FALSE,
  study_area = NULL,
  max_depth = 15,
  digits = 5,
  tol = 0.1,
  agg = NULL,
  sparse = TRUE,
  grid_shape = c(1, 1),
  verbose = TRUE,
  check = TRUE
)
}
\arguments{
\item{lines}{A SpatialLinesDataFrame with the sampling points. The
geoemtries must be a SpatialLinesDataFrame (may crash if some geometries
 are invalid)}

\item{events}{A SpatialPointsDataFrame representing the events on the
network. The points will be snapped on the network.}

\item{w}{A vector representing the weight of each event}

\item{samples}{A SpatialPointsDataFrame representing the locations for
which the densities will be estimated.}

\item{kernel_name}{The name of the kernel to use. Must be one of triangle,
gaussian, tricube, cosine ,triweight, quartic, or epanechnikov.}

\item{bw}{The kernel bandwidth (in meters)}

\item{adaptive}{A boolean, indicating if an adaptive bandwidth must be
used}

\item{trim_bw}{A float, indicating the maximum value for the adaptive
bandwidth}

\item{method}{The method to use when calculating the NKDE, must be one of
simple / discontinuous / continuous (see details for more information)}

\item{div}{The divisor to use for the kernel. Must be "n" (the number of
events within the radius around each sampling point), "bw" (the bandwith)
"none" (the simple sum).}

\item{diggle_correction}{A boolean indicating if the correction factor
for edge effect must be used.}

\item{study_area}{A SpatialPolygonsDataFrame or a SpatialPolygon
representing the limits of the study area.}

\item{max_depth}{when using the continuous and discontinuous methods, the
calculation time and memory use can go wild  if the network has a lot of
small edges (area with a lot of intersections and a lot of events). To
avoid it, it is possible to set here a maximum depth. Considering that the
kernel is divided at intersections, a value of 10 should yield good
estimates in most cases. A larger value can be used without problem for the
discontinuous method. For the continuous method, a larger value will
strongly impact calculation speed.}

\item{digits}{The number of digits to keep in the spatial coordinates. It
ensures that topology is good when building the network. Default is 3}

\item{tol}{When adding the events and the sampling points to the network,
the minimum distance between these points and the lines extremities. When
points are closer, they are added at the extermity of the lines.}

\item{agg}{a double indicating if the events must be aggregated within a distance.
if NULL, then the events are aggregated by rounding the coordinates.}

\item{sparse}{a boolean indicating if sparse or regular matrice should be
used by the Rcpp functions. Regular matrices are faster, but require more
memory and could lead to error, in particular with multiprocessing. Sparse
matrices are slower, but require much less memory.}

\item{grid_shape}{A vector of two values indicating how the study area
must be splitted when performing the calculus (see details). Defaut is c(1,1)}

\item{verbose}{A boolean, indicating if the function should print messages
about process.}

\item{check}{A boolean indicating if the geometry checks must be run before
calculating the densities}
}
\value{
A vector of values, they are the density estimates at samplings
points
}
\description{
Calculate the Network Kernel Density Estimate based on a network of lines,
sampling points, and events
}
\details{
**The three NKDE methods**\cr
Estimating the density of a point process is commonly done by using an
ordinary two dimensional kernel density function. However, there is
numerous cases for which the events do not occur in a two dimensional
space but on a network (like car crash, outdoor crimes, leaks in pipelines,
etc.). New methods were developped to adapt the methodology to networks,
three of them are available in this package.
\itemize{
  \item{method="simple"}{this first method was presented by Xie et al.
  (2008) and proposes an intuitive solution. The distances between events
  and sampling points are replaced by network distances, and the formula of
  the kernel is adapted to calculate the density over a linear unit
  instead of an areal unit.}
  \item{method="discontinuous"}{the previous method has been critized by
  Okabe et al (2008), arguing that the estimator proposed is biaised,
  conducting to overestimation of density in hot-spots of events. More
  specifically, the simple method does not conserve mass and the induced
  kernel is not a probability density along the network. They thus
  proposed a discontinuous version of the kernel function on network, which
  "divide" equaly the mass density of an event at intersections}
  \item{method="continuous"}{if the discontinuous method is unbiased, it
  leads to a discontinuous kernel function which is a bit counter-intuitive.
  Okabe et al (2008) proposed another version of the kernel, that divide
  the mass of the density at intersection but adjust the density before the
  intersection to keep the function continuous.}
}
The three methods are available because, despite the fact that the simple
method is less exact statistically speaking, it might be more intuitive.
In a purely geographical view, it migh be seen as sort of distance decay
function like used in Geographically Weighted Regression.\cr
\cr\cr
**adaptive bandwidth**\cr
It is possible to use adaptive bandiwdth instead of fixed bandwidth. The
adaptive bandwidth are calculated using the Abramsonâ€™s smoothing regimen.
To do so, a orignal fixed bandiwdth must be specified (bw parameter), and
is used to estimate a priory densities at event locations. These densities
are then used to calculate local bandwidth. The maximum size of the local
bandwidth can be limited with the parameter trim_bw. For more details, look
at the vignette a_NKDE.
\cr\cr
**Optimization parameters**\cr
The grid_shape parameter allows to split the calculus of the NKDE according
to a grid dividing the study area. It might be necessary for big dataset
to reduce the memory used. If the grid_shape is c(1,1), then a full network
is build for the area. If the grid_shape is c(2,2), then the area is
split in 4 rectangles. For each rectangle, the sample points falling in the
rectangle are used, the events and the lines in a radius of the bandwidth
length are used The results are combined at the end and ordered to match
the original order of the samples.
\cr\cr
The geographical coordinates of the start and end of lines are used to build
the network. To avoid troubles with digits, we truncate the coordinates
according to the digit parameter. A minimal loss of precision is expected
but results in a fast construction of the network.
\cr\cr
To calculate the distances on the network, all the events are added as
vertices. To reduce the size of the network, it is possible to reduce the
number of vertices by adding the events at the extremity of
the lines if they are close to them. This is controled by the parameter tol.
\cr\cr
In the same way, it is possible to limit the number of vertices by
aggregating the events that are close to each other. In that case, the
weights of the aggregated events are summed. According to an aggregation
distance, a buffer is drawn around the fist event, each other event falling
in that buffer are aggregated to the first event, forming a new event. The
coordinates of this new event are the mean of the original events
coordinates. This procedure is repeated until no events are aggregated. The
aggregation distance can be fixed with the parameter agg.
\cr\cr
When using the continuous and discontinuous kernel, the density is reduced
at each intersection crossed. After 3 intersections with four directions
each, the density is divided by 27 (3x3x3), leading to very small values.
To reduce calculation time with a small precision loss, it is recommanded
to set a maximum depth value for the two methods. This is controled by the
max_depth parameter.
\cr\cr
When using the continuous and discontinuous kernel, the connexions between
graph nodes are stored in a matrix. This matrix is typically sparse, and
so a sparse matrix object is used to limit memory use. If the network is
small (typically when the grid used to split the data has small rectangles)
then a classical matrix could be used instead of a sparse one. It increases
singnificantly speed, but could lead to memory issues.
}
\examples{
data(mtl_network)
data(bike_accidents)
lixels <- lixelize_lines(mtl_network,200,mindist = 50)
samples <- lines_center(lixels)
densities <- nkde(mtl_network,
                  events = bike_accidents,
                  w = rep(1,nrow(bike_accidents)),
                  samples = samples,
                  kernel_name = "quartic",
                  bw = 300, div= "bw",
                  adaptive = FALSE,
                  method = "discontinuous", digits = 1, tol = 1,
                  agg = 15,
                  grid_shape = c(1,1),
                  verbose=FALSE)
}
