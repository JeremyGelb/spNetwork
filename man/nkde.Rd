% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/nkde_execution_functions.R
\name{nkde}
\alias{nkde}
\title{Network Kernel density estimate}
\usage{
nkde(
  lines,
  events,
  w,
  samples,
  kernel_name,
  bw,
  method,
  div = "bw",
  max_depth = 15,
  digits = 5,
  tol = 0.1,
  grid_shape = c(1, 1),
  verbose = TRUE
)
}
\arguments{
\item{lines}{A SpatialLinesDataFrame with the sampling points. The
geoemtries must be a SpatialLinesDataFrame (may crash if some geometries
 are invalid)}

\item{events}{A SpatialPointsDataFrame representing the events on the
network. The points will be snapped on the network.}

\item{w}{A vector representing the weight of each event}

\item{samples}{A SpatialPointsDataFrame representing the locations for
which the densities will be estimated.}

\item{kernel_name}{The name of the kernel to use. Must be one of triangle,
gaussian, tricube, cosine ,triweight, quartic, or epanechnikov.}

\item{bw}{The kernel bandwidth (in meters)}

\item{method}{The method to use when calculating the NKDE, must be one of
simple / discontinuous / continuous (see details for more information)}

\item{div}{The divisor to use for the kernel. Must be "n" (the number of
events within the radius around each sampling point), "bw" (the bandwith)
"none" (the simple sum).}

\item{max_depth}{when using the continuous and discontinuous methods, the
calculation time and memory use can go wild  if the network has a lot of
small edges (area with a lot of intersections and a lot of events). To
avoid it, it is possible to set here a maximum depth. Considering that the
kernel is divided at intersections, a value of 10 should yield good
estimates in most cases. A larger value can be used without problem for the
discontinuous method. For the continuous method, a larger value will
strongly impact calculation speed.}

\item{digits}{The number of digits to keep in the spatial coordinates. It
ensures that topology is good when building the network. Default is 3}

\item{tol}{When adding the events and the sampling points to the network,
the minimum distance between these points and the lines extremities. When
points are closer, they are added at the extermity of the lines.}

\item{grid_shape}{A vector of two values indicating how the study area
must be splitted when performing the calculus (see details). Defaut is c(1,1)}

\item{verbose}{A boolean, indicating if the function should print messages
about process.}
}
\value{
A vector of values, they are the density estimates at samplings
points
}
\description{
Calculate the Network Kernel Density Estimate based on a network of lines,
sampling points, and events
}
\details{
Estimating the density of a point process is commonly done by using an
ordinary two dimensional kernel density function. However, there is
numerous cases for which the events do not occur in a two dimensional
space but on a network (like car crash, outdoor crimes, leaks in pipelines,
etc.). New methods were developped to adapt the methodology to networks,
three of them are available in this package.
\itemize{
  \item{method="simple"}{this first method was presented by Xie et al.
  (2008) and proposes an intuitive solution. The distances between events
  and sampling points are replaced by network distances, and the formula of
  the kernel is adapted to calculate the density over a linear unit
  instead of an areal unit.}
  \item{method="discontinuous"}{the previous method has been critized by
  Okabe et al (2008), arguing that the estimator proposed is biaised,
  conducting to overestimation of density in hot-spots of events. More
  specifically, the simple method does not conserve mass and the induced
  kernel is not a probability density along the network. They thus
  proposed a discontinuous version of the kernel function on network, which
  "divide" equaly the mass density of an event at intersections}
  \item{method="continuous"}{if the discontinuous method is unbiased, it
  leads to a discontinuous kernel function which is a bit counter-intuitive.
  Okabe et al (2008) proposed another version of the kernel, that divide
  the mass of the density at intersection but adjust the density before the
  intersection to keep the function continuous.}
}
The three methods are available because, despite the fact that the simple
method is less exact statistically speaking, it might be more intuitive.
In a geographical mind, it migh be seen as sort of distance decay
function like used in Geographically Weighted Regression.\cr
\cr
The grid_shape parameter allows to split the calculus of the NKDE according
to a grid dividing the study area. It might be necessary for big dataset
to reduce the memory used. If the grid_shape is c(1,1), then a full network
is build for the area. If the grid_shape is c(2,2), then the area is
split in 4 rectangles. For each rectangle, the sample points falling in the
rectangle are used, the events in a radius of the bandwidth length are used
and the lines in a radius of the bandwidth length are used. The results are
combined at the end and ordered to match the original order of the samples.
\cr\cr
The geographical coordinates of the start and end nodes are used to build
the network. To avoid troubles with digits, we truncate the coordinates
according to the digit parameter. A minimal loss of precision is expected
but results in a fast construction of the network.\cr\cr
To calculate the distances on the network, all the sampling points and the
events are added as vertices. To reduce the size of the network, it is
possible to reduce the number of vertex in the network by adding the events
and the sampling points at the extremity of the lines if they are close to
them. This is controled by the parameter tol.
}
\examples{
data(mtl_network)
data(bike_accidents)
lixels <- lixelize_lines(mtl_network,200,mindist = 50)
samples <- lines_center(lixels)
densities <- nkde(mtl_network,
                  events = bike_accidents,
                  w = rep(1,nrow(bike_accidents)),
                  samples = samples,
                  kernel_name = "quartic",
                  bw = 300, div= "bw",
                  method = "discontinuous", digits = 1, tol = 1,
                  grid_shape = c(1,1),
                  verbose=FALSE)
}
